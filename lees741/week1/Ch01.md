# Ch 1: 왜 쿠버네티스인가?

## 1.1 사전 준비 - 몇 가지 핵심 용어 검토하기
| 용어            | 의미                                                       |
|---------------|----------------------------------------------------------|
| OCI (도커 이미지)  | 실행 가능한 독립형 애플리케이션을 만들기 위한 일반적인 이미지 형식                    |
| 컨테이너          | 도커 및 OCI 이미지, 일반적으로 애플리케이션 실행                            |
| 컨트롤 플레인 (마스터) | 쿠버네티스 클러스터의 두뇌, 컨테이너 스케줄링 및 모든 쿠버네티스 객체 관리가 이루어지는 곳      |
| 파드            | 실행 중인 컨테이너를 캡슐화하는 쿠버네티스 객체                               |
| kubectl       | 쿠버네티스 컨트롤 플레인과 통신하기 위한 명령행 도구                            |
| kubelet       | 클러스터 노드에서 실행되는 쿠버네티스 에이전트, 컨트롤 플레인이 동작하는 데 필요한 작업 수행     |
| 노드            | kubelet 프로세스가 실행되는 머신                                    |
| 디플로이먼트        | 쿠버네티스에서 관리되는 파드의 모음                                      |
| 데몬셋           | 디플로이먼트와 유사하지만, 클러스터의 모든 노드에서 실행된다.                       |
| CNI, CSI      | 쿠버네티스에서 실행되는 파드(컨테이너)에 대한 플러그형 네트워킹과 스토리지를 가능하게 하는 인터페이스 |

## 1.2 인프라 드리프트 문제와 쿠버네티스
### 인프라 드리프트

하드웨어, 컴플라이언스, 다른 데이터 센터의 요구사항이 변함에 따라 인프라의 구성이 의도하거나 원하는 구성과 달라지는 현상

- 여러 서버에서 자바 버전 업데이트하기
- 특정 애플리케이션이 특정 위치에서 실행되지 않도록 만들기
- 오래되거나 고장난 하드웨어의 교체나 확장, 해당 하드웨어에서의 애플리케이션 마이그레이션
- 로드 밸런싱 경로의 수동 관리
- 공통의 강제적인 설정 언어가 없는 경우 새로운 인프라 변경에 대한 문서화를 잊어버림

인프라 관리가 되질 않으면 애플리케이션이 잘못된 위치에서 실행되거나 잘못된 리소스를 할당받을 수도 있고 잘못된 스토리지 모듈에 액세스할 수도 있다.

### `kubectl`
쿠버네티스 하나로 모든 애플리케이션의 전체 상태 공간을 중앙에서 관리할 수 있는데 그 도구는 바로 `kubectl`이다.

`kubectl`은 쿠버네티스 API 서버에 REST API를 호출하는 명령행 클라이언트, 쿠버네티스 API 클라이언트를 사용해 이러한 작업을 프로그래밍적으로 할 수도 있다.

### 컨테이너화와 쿠버네티스

쿠버네티스는 리눅스 환경에서 privileged container를 사용한다. 예를 들어, 트래픽을 애플리케이션으로 라우팅하기 위한 iptables 규칙을 관리할 수 있다.

많은 기업이 수백, 수천 개의 애플리케이션을 실행하기 위한 핵심 전략으로 컨테이너화를 채택했다.

따라서 컨테이너는 앱을 실행하고, 앱에 의존하는 서비스(ex. 맞춤형 스토리지 프로비저닝, 방화벽 요구사항)를 실행하는 등의 애플리케이션 인프라를 관리하기 위한 기본 요소다.

**현재 쿠버네티스는 컨테이너 오케스트레이션과 실행을 위한 표준으로 논란의 여지가 없다!!**

## 1.3 컨테이너와 이미지
컨테이너 시대 이전의 개발자들은 애플리케이션이 실행되는 호스트에 따라 부가적인 작업을 수행해줘야 했다.

컨테이너는 실행 중인 이미지이며 이미지 내부에는 리눅스 바이너리와 애플리케이션 파일 같은 것을 포함한다.
따라서 도커와 같은 컨테이너 런타임은 이미지를 가져와 압축을 풀고 이미지 콘텐츠를 실행하는 프로세스를 시작한다.

### 격리 계층
컨테이너는 서버에서 라이브러리를 관리할 필요가 없도록 격리 계층을 가지고 있다.
가령 서로 다른 버전의 라이브러리를 필요로 하는 두 개의 애플리케이션이 있는 경우, 두 개의 컨테이너를 사용해 컨테이너 내부에서 애플리케이션을 격리할 수 있으며 각각 특정 버전의 라이브러리를 갖는다.

***"음, 제 컴퓨터에서는 실행되는데요."***

이미지를 사용하면 동일한 소프트웨어를 다른 환경의 서버에서 실행하는 것이 간단해진다.

중요한 것은 컨테이너에 대한 자동화가 필요하며, 쿠버네티스가 이러한 자동화에 적합하다는 사실이다.

> 개발자라면 쿠버네티스를 쓰자

## 1.4 쿠버네티스의 핵심 기초
쿠버네티스는 모든것을 YAML이나 JSON으로 정의된 일반 텍스트로 정의하고, **선언적**인 방식으로 이미지를 실행한다.

일반적으로 이미지를 만들기 위해서는 Dockerfile을 생성한 뒤 `docker build`를 사용해 이미지를 빌드하고 `docker push`같은 명령을 사용해 레지스트리에 푸시한다.

쿠버네티스 환경에서 컨테이너를 실행하고 싶다면 파드를 만들면 된다. 일반적으로 YAML 코드 일부를 텍스트 파일로 저장하고 `kubectl`을 사용해 실행한다.

`kubectl`은 쿠버네티스 API 서버에 연결하고 저장해야 하는 YAML 정의를 전송한다. 그러면 쿠버네티스 API 서버에 있는 파드 정의를 자동으로 가져와 어디에서 실행 중인지 확인한다.

이러한 작업을 위해서는 클러스터 내의 노드가 계속해서 발생하는 이벤트에 응답하고 API 서버와 통신하는 `kubelet`을 통해 그 노드 객체에 상태를 업데이트 해줘야 한다.

### 선언적 방식
쿠버네티스를 궁극적으로 일관된 시스템이라고 부르는데, 그 이유는 언제든지 무언가 잘못될 수 있지만 시간이 지남에 따라 원하는 상태를 갖도록 조정하기 때문이다.

이러한 모델을 사용하기 때문에 클러스터에 있는 모든 애플리케이션의 전체 상태 공간에 대한 변경을 지속적으로 요청할 수 있고, 쿠버네티스에게 몇 줄의 YAML 파일로 원하는 상태를 **선언**할 수 있다.

즉, 쿠버네티스를 사용하면 직접 클러스터에 있는 모든 웹의 원하는 상태, 네트워킹 방법, 실행 위치, 사용하는 스토리지 등을 정의할 수 있지만 기본적인 세부 사항의 구현은 쿠버네티스에 위임할 수 있다.

### 1.4.1 쿠버네티스에서 모든 인프라 규칙은 평범한 YAML로 관리된다
* 모든 컴포넌트는 쿠버네티스 API에서 객체로 표현하는 구성파일에 정의 (선언적 방식)
* 쿠버네티스는 변경 사항 적용, 모니터링, 원하는 최종 상태에 도달할 때까지 실패나 중단 해결

## 1.5 쿠버네티스의 기능
쿠버네티스의 기반은 노드로 구성된 클러스터다. 쿠버네티스는 같은 클러스터나 클러스터 내에서 실행되는 다양한 애플리케이션의 수명주기 관리를 표준화한다.
### 쿠버네티스가 복잡한 이유
애초에 쿠버네티스가 해결하기 어려운 복잡한 문제를 해결하고 있기 때문에
### 쿠버네티스 실패 시나리오
1. 노드가 마스터에 대한 응답 실패
2. 마스터가 응답하지 않는 노드의 파드를 다른 노드에 다시 할당
3. 사용자가 `kubectl`을 통해 API 호출하면 API 서버는 응답하지 않는 노드와 파드의 새로운 위치 응답
4. 파드의 서비스와 통신하는 모든 클라이언트는 파드의 새로운 위치로 라우팅
5. 응답이 멈춘 파드에 연결된 스토리지 볼륨은 새로운 파드 위치로 이동

쿠버네티스는 리눅스 스택의 수백 가지 기술에 의존한다.

## 1.6 쿠버네티스 컴포넌트와 아키텍처
* 하드웨어 인프라: 컴퓨터, 네트워크 및 스토리지 인프라, 컨테이너 레지스트리 포함
* 워커 노드: 쿠버네티스 클러스터의 기본 컴퓨팅 단위
* 컨트롤 플레인: 쿠버네티스 모체. API 서버, 스케줄러, 컨트롤러 관리자 포함

### 1.6.1 쿠버네티스 API
마이크로서비스와 컨테이너 타입의 애플리케이션 관리하려면 쿠버네티스 API 객체 선언해야 한다.

`kubectl`에 요청할 수 있는 거의 모든 것은 API 서버에 정의되고 버전 지정된 객체 사용할 수 있다.

일반적으로 모든 쿠버네티스 API 객체는 API 버전, 종류, 메타데이터 섹션을 가지고 있다.

쿠버네티스 애플리케이션은 단순히 쿠버네티스 API 서버를 대상으로 API를 호출하는 것만으로도 완전하게 관리된다.

### 네임스페이스
임의의 객체가 특정 네임스페이스 내부에 존재할 수 있게 해서 개발자에게 간단한 형태의 계층적 그룹화를 제공한다.
앱과 관련된 모든 쿠버네티스 API 객체를 분리하는 가장 명확하고 직관적인 솔루션이다.

### 가용성과 확장 가능성
쿠버네티스는 가용성이 높고 확장 가능한 분산 시스템을 실행할 때 발생하는 수많은 문제를 해결한다.
쿠버네티스의 선언적인 특성과 컨테이너 오케스트레이션을 통한 이점이 있다.

## 1.7 쿠버네티스를 사용하지 말아야 하는 경우
* 고성능 컴퓨팅: 컨테이너 사용 시 복잡성이 늘어나고 새로운 계층에서는 성능이 저하된다. 애플리케이션이 나노초 또는 마이크로초에 영향을 받을 정도로 민감한 경우 쿠버네티스를 사용하는 것이 최선의 방법은 아닐 수 있다.
* 레거시: 레거시 애플리케이션은 컨테이너화가 매우 어렵다. 이럴 때는 쿠버네티스로의 마이그레이션 비용이 상당히 클 수 있다.