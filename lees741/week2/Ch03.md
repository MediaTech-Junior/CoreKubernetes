 # Ch03. 파드 생성하기
 
> 쿠버네티스는 이미 존재하는 리눅스 OS의 기본 요소들을 통해 파드를 구축한다.

#### 파드 생성과 실행
파드가 처음 만들어진 이후 실행 준비가 될 때까지 시간 간격이 크다.

이유는 다음과 같다.
* `kubelet`이 컨테이너가 실행되어야 한다는 사실을 알아야 한다.
* `kubelte`이 컨테이너 런타임과 대화를 통해 Pause 컨테이너를 시작해 리눅스 OS가 컨테이너 네트워크를 생성할 시간을 제공한다.
  (새로운 컨테이너 네트워크 프로세스와 PID를 부트스트래핑하기 위한 초기 home 디렉토리를 만들기 위함)

### 바인드 마운트
한 위치에서 다른 위치로 디렉토리 연결해 주는 리눅스의 기본 기능.

컨테이너가 파일 트리 내의 특정 하위 경로에 있는 디렉토리를 볼 수 있게 한다.

## 3.1 kind로 쿠버네티스 기본 요소 살펴보기
쿠버네티스 예제 실행 등 학습용으로 `kind` 클러스터를 사용

## 3.2 리눅스 기본 요소란 무엇인가?
> 쿠버네티스 생테계에 있는 수많은 플러그인과 추가 기능은 모두가 동일한 리눅스 기본 빌딩 블록들을 기반으로 하기 때문에 이러한 기본적인 도구를 아는 것은 플러그인과 추가 기능을 이해하는 데 중요하다.
* `kube-proxy`는 `iptables` 규칙을 생성하고, 컨테이너 네트워크 문제를 디버깅하기 위해 `iptables` 규칙을 검사할 때가 많다.
  * `iptables`는 리눅스 상에서 방화벽을 설정하는 도구로, 패킷필터링 규칙 등을 제어할 수 있다.
* 컨테이너 스토리지 인터페이스(CSI)는 `kubelet`과 스토리지 기술 사이의 통신을 위한 소켓을 정의한다.
  * 쿠버네티스 클러스터에서 `mount`를 실행하면 OS 도구에 의존하지 않고 쿠버네티스가 관리하는 컨테이너와 볼륨 마운트의 현황을 보여준다.
* `unshare`와 `mount` 같은 컨테이너 런타임 명령어는 격리된 프로세스를 생성할 때 사용된다.
  * root 권한을 필요로 하는 명령어. 중요한 보안 경계

### 3.2.1 리눅스 기본 요소는 리소스 관리 도구다
`ls`처럼 간단해 보이는 명령어도 대용량 파일을 찾거나 사용자가 작업을 수행하기 위한 권한이 있는지 확인할 수 있는 등 강력한 리소스 관리 도구다.
#### `ls`를 통해 알 수 있는 것
* 특정 파일에 접근할 수 있는지 여부
* 임의의 디렉토리에서 사용할 수 있는 파일
* 파일이 가진 기능 (ex. 실행 가능한 파일인가?)

리눅스는 모든 것을 파일로 표현(**"everything is a file"**)하기 때문에 관리가 쉽다.

윈도우의 경우 객체를 나타내는 통일된 표현이 없기 때문에 이벤트 상태 모니터링이 더 복잡하다. 예를 들어, 윈도우 객체는 메모리에 저장되고, 윈도우 API를 통해서만 액세스 가능하며 파일 시스템을 통해서는 액세스할 수 없다.

### 3.2.2 모든 것은 파일(또는 파일 디스크립터)이다
리눅스 기본 요소들은 파일에 대한 조작, 이동, 추상화를 제공하는 작업을 하는 경우가 많다.

`ls` 명령어도 파일에서 동작한다. `ls`명령어는 파일(디렉토리도 파일)을 보고 내부 파일 이름을 읽어 **표준 출력**(이것도 파일)에 문자열로 출력한다.
* 디렉토리는 파일이면서 다른 파일의 이름을 포함하고 있다.
* 디바이스도 리눅스 커널에서는 파일로 표시된다.
  * ex. `ls` 명령어를 사용해 이더넷 장치가 컨테이너 내부에 연결되어 있는지 확인할 수 있다.
* 소켓과 파이프도 프로세스가 통신을 위해 지역적으로 사용할 수 있는 파일이다.

### 3.2.3 파일들은 합성이 가능하다
`|` 문자를 사용해 한 명령어의 출력 결과를 다른 명령어에서 사용할 수 있다.
```shell
$ ls /var/log/containers/ | grep etcd
$ find /etc | grep etcd; find /var | grep etcd
```
## 3.3 쿠버네티스에서 리눅스 기본 요소 사용하기
> 쿠버네티스에서 핵심 기능이 동작하는 방법은 직접적이든 간접적이든 리눅스 기본 요소들이 동작하는 방식과 연결될 때가 많다.
### 3.3.1 파드 실행을 위한 전제 조건
파드를 생성할 때 격리, 네트워킹, 프로세스 관리 등의 기능을 리눅스 OS에서 사용할 수 있는 여러 유틸리티를 통해 구현할 수 있다.
* `swapoff`: 쿠버네티스를 실행하기 위한 전제 조건인 메모리 스와핑을 비활성화하는 명령
  * 메모리 스와핑: 메모리에 적재한 프로세스를 보조기억장치에 잠시 적재했다가 필요할 때 다시 꺼내서 사용하는 기법
* `iptables`: 네트워크 프록시에 대한 핵심 요구사항으로, `iptables` 규칙을 생성해 파드로 보내는 패킷 제어
* `mount`: 경로의 특정 위치에 리소스 연결
  * 예를 들어, 디바이스를 홈 디렉토리에 다른 디렉토리로 노출시킬 수 있다.
* `systemd`: 클러스터에서 모든 컨테이너를 관리하기 위한 `kubelet`을 시작. 다른 프로세스를 실행하는 init 역할을 대체하는 데몬
* `socat`: 프로세스 사이의 양방향 정보 스트림을 설정. `kubectl portforward`명령이 동작하는 데 필수
* `nsenter`: 프로세스의 다양한 네임스페이스로 들어가 네트워킹, 스토리지, 프로세스 상태를 확인할 수 있는 도구.
  * 동일한 노드 내의 파드도 별도의 네임스페이스에서 실행되기 때문에 파드의 고유 IP 주소는 다른 파드와 공유되지 않는다.
* `unshare`: 네트워크(IP 주소), 마운트(루트 위치), PID(PID 1 현상) 관점에서 격리되어 실행되는 하위 프로세스를 만드는 명령어.
  * PID 1 현상: 쿠버네티스 클러스터의 모든 컨테이너가 자신을 유일한 프로그램이라고 생각하는 현상
* `ps`: 현재 실행 중인 프로그램 나열하는 명령어. `kubelet`은 프로세스를 계속 모니터링해야 하기 때문에 `ps`가 필수

### 3.3.2 간단한 파드 실행하기
YAML 파일 작성한 후 `kubectl create -f pod.yaml`등의 명령어로 파드를 생성한다.

레이블의 메타데이터를 통해 파드를 로드 밸런서 대상으로 선택하거나 쿠버네티스 API 서버에 대한 쿼리의 필터로 선택할 수 있다.
```yaml
metadata:
  name: core-k8s
  labels:
    role: just-an-example
      app: my-example-app
      organization: friends-of-manning
      creator: jay
```
파드 생성 후 `ps -ax` 명령어를 통해 파드 프로세스 상태를 살펴볼 수 있다. 사용자 수준 소프트웨어가 아닌 시스템을 다루기 때문에 `x`옵션이 중요하다.

### 3.3.3 파드의 리눅스 의존성 탐색하기
파드는 최종 사용자 관점에서 일반 프로그램과 차이가 없고, 파드가 생성된 후 `kubelet`은 서버에서 컴퓨터 프로그램이 실행될 때 하는 많은 동작을 수행한다.
* CPU, 메모리, 네임스페이스 제한을 갖는 격리된 home을 생성
* home에 이더넷 연결이 되는지 확인
* DNS 확인하거나 스토리지 액세스를 위한 일부 기본 파일에 대한 액세스 권한을 프로그램에 부여
* 프로그램에게 다른 파드로 이동해서 시작하는 것이 안전하다고 알려줌
* 프로그램이 종료될 때까지 대기
* 프로그램이 사용한 공간과 자원 정리

`kubelet`은 리눅스 시스템 관리자가 하는 일을 수행하고 있을 뿐이다.

이러한 기본적인 제어 루프를 파드의 수명주기 제어 루프라고 하며 파드의 컨테이너가 죽을 경우 이 수명주기 제어 루프를 통해 컨테이너를 다시 살려낸다.

즉, 쿠버네티스 자체는 컨테이너를 대규모 환경에서 자동화된 방식으로 실행하고 관리할 수 있도록 복잡한 방식으로 조직된 제어 루프의 집합이라고 할 수 있다.

파드가 실행되면 API 서버에 `Pod`객체에 새로운 상태 정보가 생성되고 `kubectl get pods -o yaml` 명령어를 통해 정보를 볼 수 있다.

#### JSONPath를 사용해 파드 검사하기
아주 많은 양의 YAML 파일에서 원하는 특정 저보를 필터링하기 위해 쿠버네티스의 `JSONPath`기능을 사용할 수 있다.
```shell
$ kubectl get pods -o=jsonpath='{.items[0].status.phase}'   # 파드 상태에 대한 쿼리
$ kubectl get pods -o=jsonpath='{.items[0].status.podIP}'   # 파드의 IP 주소를 쿼리
$ kubectl get pods -o=jsonpath='{.items[0].status.hostIP}'  # 실행 중인 호스트의 IP 주소를 쿼리
```
#### 파드에 마운트한 데이터 검사하기
`default-token` 볼륨: 쿠버네티스가 모든 파드에 제공하는 필드. 파드가 API 서버와 통신하기 위한 인증서를 제공한다.
볼륨 외에도 파드에 DNS 정보도 제공한다. 아래 명령어를 실행해 이를 확인할 수 있다.
```shell
$ kubectl exec -t -i core-k8s mount | grep resolv.conf
```
컨테이너 내부에서 실행하면, 실제 `resolv.conf`(리눅스에 DNS 서버의 위치를 알려줌) 파일이 있는 호스트의 볼륨 위치를 알려준다.

#### 파드 특징
* API 서버에 액세스하기 위해 인증서가 있는 스토리지 볼륨(`deafult-token`)을 갖는다.
* 10번 서브넷에 고유한 IP 주소를 갖는다.
* 10.244.0.11 IP 주소에 있는 내부 네임스페이스의 80번 포트에서 트래픽을 처리한다. 클러스터의 다른 파드들도 이 포트에 액세스할 수 있다.

서비스 없이 파드를 생성하는 경우 쿠버네티스가 네트워킹 설정을 하지 않는다.

## 3.4 처음부터 파드 만들기
> 쿠버네티스가 없던 시절 컨테이너 관리 시스템 구축하려고 하는 상황 가정
### 3.4.1 chroot를 사용해 격리 프로세스 생성하기
기본적인 컨테이너를 만들기 위해 `chroot` 명령어 사용한다.

`chroot`의 용도는 프로세스를 위한 격리된 root를 생성하는 것이다.
1. 실행할 프로그램과 프로그램이 실행되어야 하는 파일 시스템 위치 결정
2. 프로세스 실행될 환경 생성. `lib64` 디렉토리 등 `Bash` 같은 것을 실행하기 위해 필요한 디렉토리를 새로운 루트로 불러옴
3. 실행하고 싶은 프로그램을 `chroot`처리된 위치로 복사

프로그램은 완벽히 격리된 파일 시스템을 가진다.
`chroot` 환경은 오늘날 컨테이너 혁명에 있어 가장 기본적인 빌딩 블록이다.
### 3.4.2 마운트를 사용해 작업을 위한 프로세스 데이터 제공하기
컨테이너는 일반적으로 클라우드나 호스트 시스템 등 다른 곳에 있는 스토리지에 액세스해야 한다.

`mount` 명령어를 사용해 디바이스를 OS의 루트 디렉토리 아래에 있는 모든 디렉토리에 노출할 수 있다.

`mount`의 가장 간단한 사용법은 다른 위치에 있는 디스크 포인트에 대해 일정한 디렉토리 위치를 생성하는 것인데 이렇게 하면 보안에 구멍이 생긴다.
(누구든지 해당 내용을 읽거나 조작할 수 있기 때문에)
### 3.4.3 unshare를 통한 프로세스 보안
`chroot` 처리된 프로그램은 다른 파일과 격리되어 있지만 안전하지 않다. 단순히 다른 프로세스를 가려놓은 것과 같기 때문이다.

#### CVE (Common Vulnerabilities and Exposures)
`chroot` 처리된 프로세스가 다른 디렉토리에 액세스할 수 없음에도 `kubelet`등 중요한 시스템 프로세스를 한 번에 제거할 수 있다.

이처럼 컨테이너가 호스트에 대해 완전한 액세스 권한을 가지면 중요한 시스템 프로세스를 죽이거나 시스템 필수 파일을 삭제하는 등 영구적인 손상을 줄 수 있다.

`unshare -p -f` 명령어를 사용해 프로세스 공간이 완전히 격리된 터미널에서 `chroot` 처리된 `Bash`를 실행할 수 있다. 이 경우 PID가 1이 되는 것을 확인할 수 있다.
### 3.4.4 네트워크 네임스페이스 생성하기
앞의 명령어를 통해 고립된 프로세스 환경을 얻었지만 여전히 같은 네트워크를 사용한다.

`unshare -p -n -f` 명령어를 사용해 새로운 네트워크를 갖는 프로그램을 실행할 수 있다.
### 3.4.5 프로세스 상태 확인하기
새로운 네트워크 네임스페이스를 가지는 프로세스에서 `ip a` 명령어를 실행해보면 동작하는 `eth0` 디바이스가 부족한 것을 알 수 있다. 따라서 외부 주소로부터 정보를 가져오는 동작을 제대로 하지 못한다.
### 3.4.6 cgroup을 통한 CPU 조정하기
컨트롤 그룹(`cgroup`)을 통해 클러스터에서 실행 중인 애플리케이션의 리소스를 조정할 수 있다.
```yaml
resources:
  limits:
    memory: "200Mi"
  requests:
    memory: "100Mi"
```
### 3.4.7 리소스 스탠자 생성하기
리눅스에서 `cgroup` 드라이버는 일반적으로 `systemd`를 사용한다.
```shell
$ mdkir /sys/fs/cgroup/memory/chroot0                                # cgroup 생성
$ echo "10" > /sys/fs/cgroup/memory/chroot0/memory.limit_in_bytes    # 컨테이너에 10바이트의 메모리만 할당
$ echo "0" > /sys/fs/cgroup/memory/chroot0/memory.swappiness         # 스왑 공간 할당 금지
$ echo {PID} > /sys/fs/cgroup/memory/chroot0/tasks                   # OS에 cgroup에 대한 프로세스 알림
```
## 3.5 현실에서 파드 사용하기
> 현실 세계에서는 내부 서비스에 대해 API 쿼리 기능이 필요하고 안전한 방법으로 그러한 서비스들과 통신할 수 있도록 자격증명 주입이 필요하다.
> 또한, 클러스터 내의 다른 컨테이너와 통신하기 위해 적절하게 구성된 네트워크 네임스페이스와 고유 IP 주소도 필요하다.
### 3.5.1 네트워킹 문제
#### 쿠버네티스 컨테이너에서 필요한 것
* 클러스터 내부나 파드에서 파드 사이의 연결을 위해 직접 라우팅된 트래픽
* 다른 파드나 인터넷에 액세스하기 위해 라우팅된 트래픽
* 정적 IP 주소를 사용하는 서비스 뒤에서 엔드포인트 역할을 위한 로드 밸런싱된 트래픽

이러한 작업을 위해 파드의 메타데이터가 필요하고(API 서버) 시간이 지나면서 상태가 업데이트되고 채워지도록 파드를 계속 모니터링해야 한다.(`kubelet`)
### 3.5.2 iptables를 활용하여 kube-proxy의 쿠버네티스 서비스 구현 방법 이해하기
쿠버네티스 서비스 IP로 액세스하면 여러 엔드포인트 중 서비스가 가능한 하나로 자동 전달된다.

이러한 네트워킹 규칙은 `iptables`를 사용해 저수준 네트워크 라우팅을 수행하는 `kube-proxy`에 의해 완전하게 구현된다.
`iptables` 규칙은 서비스가 파드에 트래픽을 라우팅하기 위해 구현되는 가장 일반적인 방법이다.
### 3.5.3 kube-dns 파드 사용하기
#### `kube-dns` 파드 특징
* 어떤 쿠버네티스 클러스터에서도 실행
* 특별한 권한을 갖고 있지 않으며, 호스트 네트워크가 아닌 일반적인 파드 네트워크 사용
* 트래픽을 DNS 포트 표준으로 널리 알려진 53번 포트로 전송
* 기본적으로 kind 클러스터에서 실행
#### 서비스 규칙을 통해 트래픽을 DNS 파드로 라우팅하기
`iptables`의 `-j` 옵션(jump)을 통해 서비스에 액세스하려는 무엇인가 있다면 그것을 DNS 파드로 라우팅할 수 있다.
#### 엔드포인트 규칙을 사용해 개별 포트에 대한 규칙 정의하기
서비스로부터 DNS 파드로 라우팅된 트래픽에 대한 규칙을 포트별로 정의할 수 있다.
