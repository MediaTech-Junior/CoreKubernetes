# 4장: 파드 내 프로세스에서 cgroups 사용하기

## 파드와 init 프로세스

### systemd(init) 프로세스

리눅스에서 최초에 실행되며, PID 1번을 부여받는 프로세스입니다. 모든 프로세스는 이 init프로세스에서 시작해서 뻗어나갑니다.

> ### init, systemd는 무슨 차이가 있는가?
>
> systemd는 init 프로세스의 역할에 더해 **성능 개선, 몇 가지 시스템 관리 기능이 추가**되었습니다. systemd가 좀 더 최신 시스템이라고 볼 수 있습니다.
>
> 예를 들어 init과 달리 systemd는 부팅에 필요한 프로세스를 비동기로 시작합니다. 그래서 부팅속도가 더 빠릅니다.
> ([참고](https://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/7/html/system_administrators_guide/chap-managing_services_with_systemd#sect-Managing_Services_with_systemd-Introduction))

### pause 컨테이너

각 파드에는 pause 컨테이너가 있습니다. 이 프로세스는 그 파드를 관리하는 부모같은 프로세스라고 볼 수 있습니다.

- pod의 컨테이너들이 namespace를 공유하도록 설정한다.
- 파드에서 PID 1인 init 프로세스의 역할을 한다.
- 좀비 프로세스를 정리한다.

> ### 좀비 프로세스를 어떻게 정리하지?
>
> 자식 프로세스가 종료되었지만, 부모 프로세스가 그때까지도 wait()을 호출하지 않으면, 자식 프로세스는 `좀비 프로세스`로 남게됩니다.
> 여기에 더해 부모 프로세스가 종료될때까지 결국 wait()을 호출하지 않으면 `고아 프로세스`가 됩니다.
>
> `고아 프로세스`는 PID가 1인 프로세스에게 입양되는데요. pause 컨테이너는 이러한 고아 프로세스를 처리할 수 있도록 설계되어있습니다.

### static 파드

일반적인 파드는 컨트롤 플레인에 의해 관리됩니다. 하지만 **static 파드는 `kubelet`에 의해 직접 관리**됩니다.
`kubelet`이 직접 static 파드들을 모니터링하고, 다운되면 다시 구동합니다.

이 static 파드도 API 서버에서 추적할 수 있도록 `미러 파드`를 만들어 관리합니다. 그래서 `kubectl get pods -A`하면 미러파드도 볼 수 있습니다.
다만 API 서버에서는 볼 수만 있고, 실제 파드 관리는 `kubelet`이 담당합니다.

**쿠버네티스의 스케줄러같은 핵심 컴포넌트 요소들이 이 static 파드로 동작**합니다. 만약 static파드를 직접 만들고 싶다면, `/etc/kubernetes/manifest`에 yaml을 넣으면 됩니다.
그러면 kubelet이 자동으로 yaml을 감지해 static 파드를 생성해줍니다.

## cgroups를 통한 리소스 제한

프로그램은 리소스(CPU, Memory, Storage, ...)를 소모합니다. 하지만 리소스는 한정적이죠. 

파드에 리소스 제한을 두지 않는다면, 불필요한 리소스 낭비가 발생할 수 있습니다.

cgroups를 사용한다면 **파드별로 리소스 제한**을 두어, 리소스를 더 효율적으로 사용할 수 있습니다.

### cgroups

cgroups은 CPU, Memory, 디스크 I/O, 네트워크 등의 리소스를 제한하는 리눅스 커널 기능입니다. 구체적으로 몇 가지 기능을 나열하면...

 - 리소스 제한
 - 리소스 우선순위 부여
 - 리소스 모니터링
 - cgroup에 있는 모든 프로세스 중지, 다시시작 등 제어

`/sys/fs/cgroup`에 필요한 cgroup 설정을 생성하면 자동으로 cgroup이 설정됩니다. 
특정 process의 cgroup설정을 보고싶다면, `cat /proc/{PID}/cgroup`을 사용하면 됩니다.

쿠버네티스에서도 파드의 리소스를 제한하기 위해서, `kubelet`이 파드가 생성될 때 cgroup을 함께 생성합니다.

```bash
# cpu 리소스 제한 예시
# 아래 이름의 cgroup을 들어가서 확인해보면, 쿠버네티스가 설정한 cpu 제한을 볼 수 있습니다.
# ex) /sys/fs/cpu/kubelet.slice/kubelet-kubepods.slice/... 로 가서 확인 가능
2:cpu:/kubelet.slice/kubelet-kubepods.slice/...
```

> ### 왜 쿠버네티스를 사용할 때, 메모리 스와핑을 비활성화 해야할까?
>
> `kubelet`이 **메모리 스와핑을 처리하도록 설계되지 않았기 때문**입니다.
> 쿠버네티스 철학은 파드를 생성할 때, 필요한 만큼 리소스를 할당 받아 쓰는 것입니다.
> 스왑을 허용하면 컨테이너별 속도 차이가 발생할 수 있고, 성능을 예측할 수 없는 문제가 발생합니다.
> 개발시 고려해야할 점들이 많기 때문에 메모리 스왑을 꺼두어야 합니다.
>
> k8s 1.28부터는 [메모리 스왑을 베타로 지원](https://kubernetes.io/blog/2023/08/24/swap-linux-beta/)한다고 하는군요?
> 하지만 아직 운영환경에서 사용하기에는 어려워보입니다.

### HugePages

리눅스는 메모리 관리 기법으로 Paging 기술을 사용합니다. 페이지는 4KB가 기본 값인데요. 

문제는 메모리가 커지면 그만큼 페이지가 많아져서, 메모리 접근시 페이지 테이블을 스캔하느라 성능이 저하될 수 있습니다. 
물론 테이블 캐시(TLB)가 있긴 하지만 테이블의 크기가 크면, page hit가 줄어들어 성능이 크게 향상되진 않습니다.

그래서 페이지의 크기를 4KB이상으로 크게 정하는겁니다. 그러면 페이지 수가 적어지고, 테이블의 크기가 작아지고, TLB의 page hit가 늘어나 성능 향상을 기대할 수 있습니다!

물론 페이지가 적어지는만큼 멀티 프로그래밍에는 불리해집니다. 따라서 가급적 단일 프로세스를 띄우는 경우에만 HugePages를 사용하는게 좋습니다.

쿠버네티스에서도 HugePage를 지원합니다. 예를 들어 제한을 거는 경우에는 `resources.limits.hugepages-<size>`를 사용하면 됩니다.

### QoS

노드에 자원이 부족해지면, 어떤 파드를 재배치시켜야할까요? 쿠버네티스는 QoS라는 개념을 도입해서 파드 스케줄링에 활용합니다.

QoS 클래스는 3가지가 있습니다.

 - **Guaranteed**: 리소스 제한, 요청을 동일하게 기입한 경우. 자원 사용을 가장 안정적으로 보장받습니다.
 - **Burstable**: 리소스 요청이 있지만, 제한은 없는 경우(또는 제한이 요청보다 큰 경우).
 - **BestEffort**: 아무런 리소스 제한, 요청이 없는 경우.

쿠버네티스는 노드에 리소스가 부족해지면, QoS와 리소스 사용량을 기준으로 어떤 파드를 재배치할지 결정합니다.

**Guaranteed > Burstable > BestEffort** 순으로 높은 우선순위를 가집니다.

예를 들어 노드에 메모리가 부족하다고 해볼게요.
 - 해당 노드는 MemoryPressure 상태가 되며, 더 이상 파드를 생성하지 않습니다.
 - QoS와 메모리 사용량을 기준으로 **재배치할 파드들을 결정**합니다.
 - 선택한 파드들을 **다른 노드로 재배치**합니다.

이 QoS를 설정해서 중요한 서비스 자원을 안정적으로 보장할 수 있습니다. 결국 서비스 품질을 향상시킬 수 있습니다.

## 시스템 모니터링

### 메트릭

수량화 가능한 값을 의미합니다. 예를 들면 cpu 사용량, 메모리 사용량 등...

메트릭은 크게 세 가지 유형이 있습니다.

 - **Gauge**: 단위 시간동안 발생한 이벤트 수 표시
 - **Histogram**: 이벤트를 시간 간격으로 표시
 - **Counter**: 이벤트 발생 횟수 표시

이 메트릭은 프로메테우스를 활용해서 수집하고 관리할 수 있습니다. cgroups는 리소스 통계도 제공하는데, 이를 활용해서 시스템을 모니터링할 수 있습니다.

또한 메트릭은 반드시 컴퓨터 시스템 정보일 필요는 없습니다. 예를 들어서 비즈니스적으로 유용한 정보들(PV, 페이지 잔류 시간 등)도 메트릭으로 넣을 수 있습니다.

이러한 메트릭들을 수집하고 모니터링하며 서버를 더 안정적으로 관리할 수 있습니다.
더 나아가서는 중요한 비즈니스 결정을 내리는데에 사용될 수도 있습니다.