# 1장: 왜 쿠버네티스인가?

## 컨테이너

### 컨테이너와 이미지

- **이미지**: 애플리케이션과 필요한 환경(라이브러리, 프레임워크 등)들을 모아둔 패키지
- **컨테이너**: 이미지를 실행한 것. 도커와 같은 엔진을 통해 실행한다.
    - 외부, 다른 컨테이너와 격리되어있다.
    - 하나의 이미지로 여러 컨테이너를 띄우면 환경 일관성을 보장해주기도 한다.
    - 하드웨어가 아닌, 애플리케이션 수준에서 가상화되므로 VM에 비해 훨씬 가볍다.

### 컨테이너 시스템이 필요한 이유

- **배포 편의성**: 애플리케이션을 개발하고, 테스트, 배포, 관리가 간편해진다.
- **확장 가능성**: 수평 확장을 쉽게 구현할 수 있다.
- **일관성 있는 환경 제공**: 같은 환경에서 구동
- **독립된 환경 제공**: 논리적으로 분리된 환경을 제공한다.

## 쿠버네티스

### 많은 컨테이너 관리하기

서비스의 규모가 커지면 수많은 컨테이너들을 관리해야한다. 이 과정에서 겪게되는 몇 가지 고민 포인트들이 있는데...

- 트래픽 규모에 따라 컨테이너들을 늘려주거나 줄여주어야 한다.
- 컨테이너가 다운되면, 다시 실행시켜야 한다. 그동안 트래픽 처리량이 감소한다.
- 수 많은 컨테이너간 로드벨런싱 문제
- 여러 컨테이너간 무중단 배포를 위해 복잡한 배포 스크립트를 작성해야한다.

### 컨테이너 오케스트레이션

**컨테이너들의 배포, 관리, 확장 등을 자동화하는 것.** 현재는 쿠버네티스가 가장 많이 사용되고 있다.

### 지원하는 핵심 기능

 - **YAML을 통한 손쉬운 관리**: 각종 인프라들을 YAML로 관리한다. 스팩 정의, 규칙, 관리 등 일관성있게 통합된 방법을 제공한다.  
 - **자동화 롤아웃 및 롤백**: 배포 과정에서 안정적으로 최소 1개 이상의 팟이 실행됨을 보장하며, 점진적으로 배포한다. 만약 문제가 발생하면 롤백하는 기능도 지원한다.
 - **로드밸런싱**: 여러 Pod들을 대상으로 다양한 로드밸런싱 방법을 제공한다.
 - **고가용성 보장**
   - Pod이 죽으면 재시작한다.
   - Pod이 완전히 시작되기 전까지 라우팅하지 않는다.
 - **자동 확장**: CPU/Memory 사용량에 따라 자동으로 Pod을 늘리거나 줄인다.

### 쿠버네티스 API

Pod, Namespace, Service 등... 쿠버네티스 API 오브젝트들을 조작할 수 있도록 제공하는 API

 - 쿠버네티스는 **Pod을 지원하기 위한 많은 요소들을 제공**한다. (Service, PV/PVC, Deployment, ...)
 - `kubectl`을 사용하면 직관적인 커맨드라인 명령어로 쿠버네티스 API를 사용할 수 있다.

### 사용하지 말아야 하는 경우

이 부분은 `사용하지 말아야 하는 경우`가 아니라, `사용을 고려해보아야 하는 경우`들을 언급한다.

 - **고성능 컴퓨팅**: 컨테이너 관리 서비스 자체에 약간의 성능 저하가 있다. 성능에 매우 민감한 경우(ms, ns에 영향받는 서비스) 문제될 가능성 있음.
 - **레거시**: 소프트웨어 설계, 대기시간 요구사항, 쿠버네티스 클러스터에서 실행할 수 없는 소프트웨어 등...
 - **마이그레이션**: 쿠버네티스로 마이그레이션하는 비용은 크다. 그런데 이 작업이 그만큼 효용성이 있는지 검토해보야아한다.