# Chapt 2. 왜 파드인가?

## 파드

- 파드의 추상화는 컨테이너 전환에 있어 핵심부분이다.
- 쿠버네티스 클러스테에 배치될 수 이있는 가장 작은 원자적 단위이다.
- 여러 컨테이너를 포함하고 있다.
- 노드에서 컨테이너로 실행되는 이미지.
- 대부분 직접 배포하기보다 파드를 정의하는 다양한 API(디플로이먼트, 잡, 스테이트풀셋, 데몬셋 등)에 의해 생성된다.

```
#파드를 조회할수 있는 명령어
kubectl get po
```

### 네임스페이스

파드는 다음과 같은 네임스페이스를 갖는다

- IPC
- cgroup
- mnt
- user

### 노드

노드는 kubelet을 실행하는 서버

노드는 다음을 포함하고 있어야 한다.

- 서버
- OS
- systemd(리눅스의 시스템 및 서비스 관리자)
- kubelet(노드 에이전트)
- 컨테이너 런타임(도커 엔진)
- 네트워크 프록시(kube-proxy)
- CNI(Container Network Interface) 공급자

#### kubelet

- 쿠버네티스 API 와 통신하게 해주는 에이전트로 모든 노드에서 반드시 실행되어야 한다
- 만약 실행되지 않는다면 노드가 스케줄링할 수 없거나 클러스터에 포함되지 않을 수 있다.
- 모든 파드는 kubelet을 통해 실행된다.
- API 서버는 하트비트를 통해 kubelet의 상태를 확인한다.( >= 1.17)
- 가비지 수집

논리적인 동작 : Kubelet
실제적인 동작 : CNI, CRI 를 통해

#### 서비스

kube-porxy(쿠버네티스 네트워크 프록시 바이너리)를 통해 TCP, UDP, STCP 등 네트워크 프로토콜과 포워딩, 로드밸런싱을 지원한다

```
단, CNI 공급자에 따라 자체 소프트웨어로 대체될 수 있음
```

- ClusterIP: 쿠버네티스 파드의 로드밸런싱을 하는 내부 서비스
- NodePort: 다양한 파드의 로드밸런싱을 하는 쿠버네티스 노드의 개방형 포트
- LoadBalancer: 클러스터 외부에 로드 밸런서를 생성하는 외부 서비스

---

배포를 실행하면 첫 번째로 kubectl은 kube-apiserver 와 통신한다.

#### kube-apiserver

다양한 API객체를 노출하는 HTTP기반 REST 서버.

- 노드가 시작되었을 때 kubelet은 API 서버와 통신해 클러스터에 등록되었는지 확인한다.
- etcd(쿠버네티스 데이터베이스) 와 통신하는 유일한 컴포넌트
- 인증, 인가 기능 제공
- 웹훅 제공

---

이 후, 노드에서 파드를 가져오기 위해 스케줄러를 설정한다.

### kube-scheduler

지정된 규칙에 따라 파드를 특정 노드에 할당한다.

- 파드 선호도(Pod affinity): 규칙과 일치하는 노드에 파드를 할당
- 파드 반선호도(Pod anti-affinity): 규칙과 일치하는 노드에서 파드 제거
- 테인트(Taint): 노드가 파드세트에 접근하지 못하게 함

---

다음은 영구 디스크가 필요한 경우 동작하는 방식.

### 인프라 컨트롤러

쿠버네티스 컨트롤러 관리자(KCM), kube-controller-manager, 클라우드 컨트롤러 관리자(CCM)등이 있다.

```
1.6 이후 KCM -> CCM 으로 이전작업이 진행되어 클라우드 벤더사에 의존적으로 동작하지 않게 되었다!
```

CCM 은 클라우드 기반 API 호출을 실행 및 컨트롤러 루프를 실행한다.

CCM이 관리하는 컨트롤러의 목록

- 노드 컨트롤러: KCM과 동일한 코드 실행
- 라우트 컨트롤러: 기본 클라우드 인프라에서 경로 설정
- 서비스 컨트롤러: 클라우드 공급자 로드밸런서 관리
- 볼륨 컨트롤러: 볼륨 생성 및 연결, 마운트

위 컨트롤러들은 벤더 중립적이기 위해 클라우드 공급자 인터페이스에 대해 동작한다.

- 컨테이너 네트워킹 인터페이스(CNI): 파드에 IP 주소 제공
- 컨테이너 런타임 인터페이스(CRI): 다양한 컨테이너 실행 엔진 정의 및 연결
- 컨테이너 스토리지 인터페이스(CSI): 새로운 스토리지 타입을 지원

CCM(KCM)은 스토리지를 생성해 노드에 마운트 한다.  
pod를 생성한 kubelet은 어느 스토리지에 연결할지 결정하게 된다.

CCM(KCM)새로운 로드밸런서가 필요하다는 사실을 감지하면 클라우드에 로드밸런서 생성 API 요청 or 외부 로드밸런서 호출을 통해 트래픽을 전달한다.  
이후, 노드에 있는 CNI 공급자를 통해 트래픽을 파드로 라우팅한다.

### 고가용성

세 가지 수준의 문제

- 파드 중단(Pod outage)
- 노드 중단(Node outage)
  - 파드가 노드에 스케줄링 되지 않을 수 있음
  - 해당 노드에 존재하는 파드는 삭제 후 리스케줄링
- 소프트웨어 업데이트 중단

쿠버네티스는 이러한 문제에 대해 우아하게 종료 후 재시작하는 것을 지원한다.

```
- kubectl edit: API 객체를 편집하기 위한 터미널을 연다
- kubectl apply: 파일을 입력받아 교체
- kubectl patch: 객체에 대한 차의를 정의하는 패치 파일 적용
```

#### 자동확장

이러한 작업을 수동으로 하는 것은 비효율적 -> 자동확장 기능을 이용

- 파드 생성: HorizontalPodAutoscaler Scale Out
- 파드 리소스 증가: VerticalPodAutoscaler Scale Up
- 노드 생성: Cluster Autoscaler Scale out

이러한 자동확장은 비용의 증가로 이어지기 때문에 비용관리가 필요하다.  
비용관리의 핵심은 파드 밀도(Pod density)가 높아져야 한다.

파드 밀도를 다음 단계에 따라 제어한다.

1. 애플리케이션의 크기와 프로파일링
   - 메모리, CPU 사용량에 대해 테스트를 통해 프로파일링 한다.
2. 노드 크기 선택
3. 특정 노드에 대한 특정 애플리케이션의 그룹화

가장 중요한 요소는 **시끄러운 이웃(Noisy Neighbor Problem)**

> 시끄러운 이웃?  
> 클라우드 환경에서 특정 물리 장비(pm)에서 동작하는 여러 vm 중 특정 vm이 자원을 많이 사용함으로서 다른 vm이 자원을 사용하지 못하는 현상

Pod affinity & Pod anti-affinity 를 이용해 nosiy neighbor 를 분산 시켜야 한다.
